#ifndef __TOPOLOGY_TOPOLOGY_HPP__
#define __TOPOLOGY_TOPOLOGY_HPP__

#include "Particle.hpp"
#include "ParticleCollection.hpp"
#include "Spring.hpp"
#include "SpringCollection.hpp"
#include "nsearch.hpp"

#include "SpringNetwork.h"
namespace biospring
{
namespace topology
{

// Topology class.
//
// A `Topology` is a collection of `Particle`s and `Spring`s.

class Topology
{
  protected:
    // The particles in the topology.
    ParticleCollection _particles;

    // The springs in the topology.
    SpringCollection _springs;

  public:
    // =============================================================================
    // Initialization methods.
    // =============================================================================

    Topology() : _springs(_particles) {}

    // Copy constructor.
    Topology(const Topology & other) : _springs(_particles)
    {
        _copy_particles(other);
        _copy_springs(other);
    }

    // Assignment operator.
    Topology & operator=(const Topology & other)
    {
        // This preserves any springs that may already have been added when 
        // parsing the input topology file (see pdb2spn and PDBPreader).
        // Useful, for example, for keeping the springs defined by the CONECT 
        // lines of a coarse-grained topology generated by the martinize tool, 
        // which is given as input to pdb2spn.
        // Reset the springs only if the number of particles in the new topology
        // after reduction is not equal to that in the input topology.
        // If the topology has not been reduced, for example an already 
        // coarse-grained martini representation structure to which we simply 
        // assign the names of the particles and their parameters via the --ff 
        // and --grp options in pdb2spn (see the Martini ff and grp file in 
        // /data/martini).
        if (_particles.size() != other._particles.size())
        {
            _springs.clear();
        }
        
        _copy_particles(other);
        _copy_springs(other);

        return *this;
    }

    // =============================================================================
    // Capacity.
    // =============================================================================

    size_t number_of_particles() const { return _particles.size(); }
    size_t number_of_springs() const { return _springs.size(); }

    // =============================================================================
    // Particle manipulation.
    // =============================================================================

    // Adds a particle to the topology.
    void add_particle(const Particle & particle) { _particles.push_back(particle); }

    // Adds a collection of particles to the topology.
    template <typename container> void add_particles(const container & particles) { _particles.push_back(particles); }
    void add_particles(const std::initializer_list<Particle> & particles) { _particles.push_back(particles); }

    // =============================================================================
    // Spring manipulation.
    // =============================================================================

    // Creates a spring between two particles.
    auto & add_spring(Particle & p1, Particle & p2, double equilibrium = -1.0, double stiffness = 1.0)
    {
        return _springs.add_spring(p1, p2, equilibrium, stiffness);
    }

    // Creates a spring between two particles using their position in the list of particles.
    auto & add_spring(size_t p1, size_t p2, double equilibrium = -1.0, double stiffness = 1.0)
    {
        return _springs.add_spring(_particles[p1], _particles[p2], equilibrium, stiffness);
    }

    // Adds springs between all particles within a cutoff distance.
    // Equilibrium distance is set to the distance bewteen each pair.
    void add_springs_from_cutoff(double cutoff, double stiffness = 1.0)
    {
        // Initializes the neighbor search object.
        nsearch::NeighborSearch nsearch(_particles, cutoff);

        // Iterates over all particles.
        for (Particle & p : _particles)
        {
            // Gets the neighbors of the current particle.
            auto neighbor_indexes = nsearch.get_neighbors(p);

            // Iterates over the neighbors.
            for (auto & neighbor_index : neighbor_indexes)
            {
                Particle & neighbor = _particles[neighbor_index];

                // If both particles are static, skip them.
                if (p.properties().is_static() && neighbor.properties().is_static())
                    continue;

                // Adds a spring between the current particle and the neighbor.
                // In this context, it's possible that we're trying to add a spring that
                // already exists.
                try
                {
                    auto & spring = add_spring(p, neighbor);
                    spring.set_stiffness(stiffness);
                }
                catch (const SpringAlreadyExistsException & e)
                {
                }
            }
        }
    }

    // Adds springs betweens particles that originate from different topologies.
    // This function's main purpose is to add springs between particles during
    // topology merging.
    void add_springs_between_topologies_from_cutoff(double cutoff, double stiffness = 1.0)
    {
        // Initializes the neighbor search object.
        nsearch::NeighborSearch nsearch(_particles, cutoff);

        // Iterates over all particles.
        for (Particle & p : _particles)
        {
            // Gets the neighbors of the current particle.
            auto neighbor_indexes = nsearch.get_neighbors(p);

            // Iterates over the neighbors.
            for (auto & neighbor_index : neighbor_indexes)
            {
                Particle & neighbor = _particles[neighbor_index];

                // If the neighbor is in the same topology, skip it.
                if (p.properties().topology_id() == neighbor.properties().topology_id())
                    continue;

                // If both particles are static, skip them.
                if (p.properties().is_static() && neighbor.properties().is_static())
                    continue;

                // Adds a spring between the current particle and the neighbor.
                // In this context, it's possible that we're trying to add a spring that
                // already exists.
                try
                {
                    auto & spring = add_spring(p, neighbor);
                    spring.set_stiffness(stiffness);
                }
                catch (const SpringAlreadyExistsException & e)
                {
                }
            }
        }
    }

    // =============================================================================
    // Particle Getters.
    // =============================================================================

    auto & particles() { return _particles; }
    const auto & particles() const { return _particles; }

    auto & get_particle(size_t position) { return _particles[position]; }
    const auto & get_particle(size_t position) const { return _particles[position]; }

    auto & get_particle_at_uid(pid_t uid) { return _particles.at_uid(uid); }
    const auto & get_particle_at_uid(pid_t uid) const { return _particles.at_uid(uid); }

    // =============================================================================
    // Spring Getters.
    // =============================================================================

    auto & springs() { return _springs; }
    const auto & springs() const { return _springs; }

    auto & get_spring(size_t position) { return _springs[position]; }
    const auto & get_spring(size_t position) const { return _springs[position]; }

    auto & get_spring(pid_t uid1, pid_t uid2) { return _springs.at_uid({uid1, uid2}); }
    const auto & get_spring(pid_t uid1, pid_t uid2) const { return _springs.at_uid({uid1, uid2}); }

    auto & get_spring(const Particle & p1, const Particle & p2)
    {
        return _springs.at_uid({p1.unique_id(), p2.unique_id()});
    }

    auto & get_spring_at_uid(sid_t uid) { return _springs.at_uid(uid); }
    const auto & get_spring_at_uid(sid_t uid) const { return _springs.at_uid(uid); }

    // =============================================================================
    // Spring Lookup.
    // =============================================================================

    bool has_spring_between(const Particle & p1, const Particle & p2) const { return _springs.exists(p1, p2); }

    // =============================================================================
    // Merge.
    // =============================================================================

    // Returns a new Topology which is the result of merging two topologies.
    // The new topology will contain all particles and springs from both topologies.
    static Topology merge(const Topology & top1, const Topology & top2)
    {
        Topology result;
        result._particles += top1._particles + top2._particles;
        result._copy_springs(top1);
        result._copy_springs(top2);
        return result;
    }

    Topology merge(const Topology & other) const { return merge(*this, other); }

    // =============================================================================
    // Conversion.
    // =============================================================================

    // Converts the topology to a SpringNetwork.
    // The result is passed as argument because SpringNetwork has no copy constructor.
    void to_spring_network(spn::SpringNetwork & spn) const
    {
        // Removes all springs and particles from the SpringNetwork.
        spn.clear();

        // Copies particles.
        for (const topology::Particle & source : _particles)
        {
            spn::Particle target;
            target.setName(source.properties().name());
            target.setResName(source.properties().residue_name());
            target.setResId(source.properties().residue_id());
            target.setChainName(source.properties().chain_name());
            target.setExtid(source.properties().atom_id());
            target.setMass(source.properties().mass());
            target.setCharge(source.properties().charge());
            target.setRadius(source.properties().radius());
            target.setPosition(source.properties().position());
            target.setVelocity(source.properties().velocity());
            target.setForce(source.properties().force());
            target.setDynamic(source.properties().is_dynamic());
            target.setHydrophobicity(source.properties().hydrophobicity());
            target.setSolventAccessibilitySurface(source.properties().imp().solvent_accessible_surface());
            target.setTransferEnergyByAccessibleSurface(source.properties().imp().transfert_energy_by_accessible_surface());

            spn.addParticle(target);
        }

        // Copies springs.
        for (const topology::Spring & source : _springs)
        {
            // Retrieves the positions of the particles making up the spring.
            size_t i = _particles.by_uid().at(source.first().unique_id());
            size_t j = _particles.by_uid().at(source.second().unique_id());

            spn.addSpring(i, j, source.equilibrium(), source.stiffness());
        }
    }

  protected:
    // Copies `other`'s particles to this topology.
    void _copy_particles(const Topology & other)
    {
        // Copies particles.
        _particles = other._particles;
    }

    // Copies `other`'s springs to this topology.
    void _copy_springs(const Topology & other)
    {
        // Copies springs.
        for (const Spring & source : other._springs)
        {
            // Retrieves the positions of the particles making up the spring.
            size_t i = other._particles.by_uid().at(source.first().unique_id());
            size_t j = other._particles.by_uid().at(source.second().unique_id());

            _springs.add_spring(_particles[i], _particles[j], source.equilibrium(), source.stiffness());
        }
    }
};

} // namespace topology
} // namespace biospring

#endif // __TOPOLOGY_TOPOLOGY_HPP__